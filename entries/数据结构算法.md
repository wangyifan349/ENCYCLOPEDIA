# 常用算法详解与示例代码

本文档总结了若干常见算法的原理、实现及示例代码，涵盖排序算法、KMP字符串匹配算法以及单源最短路径算法，便于学习和复习。

---

## 1. 排序算法

排序算法是计算机科学中基础且重要的算法，广泛应用于数据处理、查找等场景。以下介绍五种常见排序算法：

### 1.1 冒泡排序（Bubble Sort）

**原理：**  
重复遍历待排序序列，比较相邻元素并交换，较大的元素逐渐“冒泡”至序列末尾。  
**时间复杂度：** 最坏和平均为O(n²)，空间复杂度O(1)，稳定排序。

```python
def bubble_sort(arr):
    """
    冒泡排序
    """
    n = len(arr)
    for i in range(n):
        for j in range(n - 1 - i):
            if arr[j] > arr[j + 1]:
                arr[j], arr[j + 1] = arr[j + 1], arr[j]
```

---

### 1.2 选择排序（Selection Sort）

**原理：**  
每次从未排序部分选择最小元素，交换到当前排序位置。  
**时间复杂度：** O(n²)，空间复杂度O(1)，不稳定排序。

```python
def selection_sort(arr):
    """
    选择排序
    """
    n = len(arr)
    for i in range(n):
        min_index = i
        for j in range(i + 1, n):
            if arr[j] < arr[min_index]:
                min_index = j
        arr[i], arr[min_index] = arr[min_index], arr[i]
```

---

### 1.3 插入排序（Insertion Sort）

**原理：**  
将元素逐一插入到已排序序列的合适位置。  
**时间复杂度：** 平均O(n²)，若序列基本有序可达到O(n)，空间复杂度O(1)，稳定排序。

```python
def insertion_sort(arr):
    """
    插入排序
    """
    n = len(arr)
    for i in range(1, n):
        key = arr[i]
        j = i - 1
        while j >= 0 and arr[j] > key:
            arr[j + 1] = arr[j]
            j -= 1
        arr[j + 1] = key
```

---

### 1.4 快速排序（Quick Sort）

**原理：**  
采用分治策略，通过划分操作将序列分为左右两部分，分别递归排序。  
**时间复杂度：** 平均O(n log n)，最坏O(n²)，空间复杂度O(log n)，不稳定排序。

```python
def quick_sort(arr):
    """
    快速排序
    """
    def partition(array, low, high):
        pivot = array[high]
        i = low - 1
        for j in range(low, high):
            if array[j] <= pivot:
                i += 1
                array[i], array[j] = array[j], array[i]
        array[i + 1], array[high] = array[high], array[i + 1]
        return i + 1

    def quick_sort_recursive(array, low, high):
        if low < high:
            pi = partition(array, low, high)
            quick_sort_recursive(array, low, pi - 1)
            quick_sort_recursive(array, pi + 1, high)

    quick_sort_recursive(arr, 0, len(arr) - 1)
```

---

### 1.5 归并排序（Merge Sort）

**原理：**  
采用分治思想，将序列拆分成两半分别排序，最后合并有序序列。  
**时间复杂度：** O(n log n)，空间复杂度O(n)，稳定排序。

```python
def merge_sort(arr):
    """
    归并排序，返回排序后的新数组
    """
    if len(arr) <= 1:
        return arr

    mid = len(arr) // 2
    left_half = merge_sort(arr[:mid])
    right_half = merge_sort(arr[mid:])

    return merge(left_half, right_half)

def merge(left, right):
    merged = []
    i = j = 0
    while i < len(left) and j < len(right):
        if left[i] <= right[j]:
            merged.append(left[i])
            i += 1
        else:
            merged.append(right[j])
            j += 1
    merged.extend(left[i:])
    merged.extend(right[j:])
    return merged
```

---

## 2. KMP字符串匹配算法

**原理：**  
Knuth-Morris-Pratt算法利用模式串自身信息，高效地进行字符串匹配，避免无谓的回溯。  
**时间复杂度：** O(n + m)，n为文本长度，m为模式串长度。

```python
def compute_lps_array(pattern):
    """
    计算模式串的最长前缀后缀（LPS）数组
    """
    length = 0
    lps = [0] * len(pattern)
    i = 1
    while i < len(pattern):
        if pattern[i] == pattern[length]:
            length += 1
            lps[i] = length
            i += 1
        else:
            if length != 0:
                length = lps[length - 1]
            else:
                lps[i] = 0
                i += 1
    return lps

def kmp_search(text, pattern):
    """
    KMP搜索，返回所有匹配起始索引
    """
    if not pattern:
        return []

    lps = compute_lps_array(pattern)
    result = []
    i = j = 0
    while i < len(text):
        if text[i] == pattern[j]:
            i += 1
            j += 1
        else:
            if j != 0:
                j = lps[j - 1]
            else:
                i += 1
        if j == len(pattern):
            result.append(i - j)
            j = lps[j - 1]
    return result
```

---

## 3. 单源最短路径算法

### 3.1 Dijkstra算法

**原理：**  
贪心算法，适用于无负权边的图，使用优先队列（堆）实现。  
**时间复杂度：** O(E log V)  

```python
import heapq

def dijkstra_shortest_path(graph, start_node):
    distances = {node: float('inf') for node in graph}
    distances[start_node] = 0
    priority_queue = [(0, start_node)]

    while priority_queue:
        current_distance, current_node = heapq.heappop(priority_queue)
        if current_distance > distances[current_node]:
            continue
        for neighbor, weight in graph[current_node]:
            distance_new = current_distance + weight
            if distance_new < distances[neighbor]:
                distances[neighbor] = distance_new
                heapq.heappush(priority_queue, (distance_new, neighbor))
    return distances
```

---

### 3.2 Bellman-Ford算法

**原理：**  
可处理含负权边但无负环的图，时间复杂度较Dijkstra高。  
**时间复杂度：** O(V * E)

```python
def bellman_ford_shortest_path(edges, node_count, start_node):
    distances = [float('inf')] * node_count
    distances[start_node] = 0

    for _ in range(node_count - 1):
        updated = False
        for u, v, w in edges:
            if distances[u] != float('inf') and distances[u] + w < distances[v]:
                distances[v] = distances[u] + w
                updated = True
        if not updated:
            break
    for u, v, w in edges:
        if distances[u] != float('inf') and distances[u] + w < distances[v]:
            return None  # 负权环存在
    return distances
```

---

## 4. 示例代码演示

```python
if __name__ == "__main__":
    # 排序演示
    sample = [64, 25, 12, 22, 11]

    arr = sample[:]
    bubble_sort(arr)
    print("冒泡排序:", arr)

    arr = sample[:]
    selection_sort(arr)
    print("选择排序:", arr)

    arr = sample[:]
    insertion_sort(arr)
    print("插入排序:", arr)

    arr = sample[:]
    quick_sort(arr)
    print("快速排序:", arr)

    arr = sample[:]
    arr = merge_sort(arr)
    print("归并排序:", arr)

    # KMP演示
    text = "ABABDABACDABABCABAB"
    pattern = "ABABCABAB"
    pos = kmp_search(text, pattern)
    print("KMP匹配位置:", pos)

    # Dijkstra演示
    graph = {
        'A': [('B', 1), ('C', 4)],
        'B': [('C', 2), ('D', 5)],
        'C': [('D', 1)],
        'D': []
    }
    dist = dijkstra_shortest_path(graph, 'A')
    print("Dijkstra最短路径:", dist)

    # Bellman-Ford演示
    edges = [
        (0, 1, 1),
        (1, 2, 2),
        (0, 2, 4),
        (2, 3, 1),
        (3, 1, -3),
    ]
    nodes = 4
    dist_bf = bellman_ford_shortest_path(edges, nodes, 0)
    if dist_bf is None:
        print("Bellman-Ford检测到负权环")
    else:
        print("Bellman-Ford最短路径:", dist_bf)
```

---

**备注：**  
此文档适合作为算法学习参考和代码备忘，示例代码简洁易懂，适合快速理解和实践。
